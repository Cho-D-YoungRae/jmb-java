# Chapter 16. 비트마스크

## 16.1 도입

**비트마스크를 사용하는 코드의 장점**

- 더 빠른 수행시간
- 더 간결한 코드
- 더 작은 메모리 사용량
- 연관 배열을 배열로 대체

**유의할 점들**

- 연산자 간 우선순위 혼동
- 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로
- 부호 있는 정수형 사용
- N비트 정수를 N비트 이상 왼쪽으로 시프트

## 16.2 비트마스크를 이용한 집합의 구현

**공집합과 꽉 찬 집합 구하기**

공집합은 0

```java
// 스무 개의 토핑을 모두 포함하는 집합
int toppings = (1 << 20) - 1;
```

**원소 추가**

```java
toppings |= (1 << p);
```

**원소의 포함 여부 확인**

```java
if ((toppings & (1 << p)) != 0) {
    // p가 포함되어 있다.
}
```

**원소의 삭제**

```java
toppings &= ~(1 << p);
```

**원소의 토글**

```java
toppings ^= (1 << p);
```

**두 집합에 대해 연산하기**

```java
int added = (a | b);        // a와 b의 합집합
int intersection = (a & b); // a와 b의 교집합
int removed = (a & ~b);     // a에서 b를 뺀 차집합
int toggled = (a ^ b);      // a와 b 중 하나에만 포함된 원소들의 집합
```

**집합의 크기 구하기**

```java
// toppings에 켜진 비트의 수
int bitCount = Integer.bitCount(toppings);
```

**최소 원소 찾기**

```java
// 켜져 있는 최하위 비트의 위치
int lowest = Integer.lowestOneBit(toppings);
```

**최소 원소 지우기**

```java
toppings &= (toppings - 1);
```

- 2의 거듭제곱 값인지 확인할 떄도 유용하게 사용됨
  - 2의 거듭제곱 값들의 이진수 표현에는 켜진 비트가 하나밖에 없기 때문에, 최하위 비트를 지웠을 떄 0이 된다면 주어진 수는 2의 거듭제곱

**모든 부분 집합 순회하기**

예를들어 pizza가 {페퍼로니, 소시지, 양파}라면 {페퍼로니}, {페퍼로니, 소시지}, {페퍼로니, 소시지, 양파}, {페퍼로니, 양파}, {소시지}, {소시지, 양파}, {양파}를 순회

```java
for (int subset = pizza; subset != 0; subset = ((subset - 1) & pizza)) {
    // subset은 pizza의 부분집합
}
```

## 16.3 비트마스크의 응용 예제

- 지수 시간 동적 계획법
- 에라토스테네스의 체
- 15퍼즐 상태 표현하기
- O(1) 우선순위 큐